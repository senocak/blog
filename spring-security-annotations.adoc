= Spring Security Annotations
:source-highlighter: highlight.js
Anıl Şenocak <senocakanil@gmail.com>
2.0, April 16, 2024
:description: Bu annotation'ları kullanarak, uygulamanın kaynaklarına kimlerin erişebileceğini ve bu kaynaklarla nasıl etkileşimde bulunabileceklerini kontrol edebiliriz.
:organization: Personal
:doctype: book
:preface-title: Preface
// Settings:
:experimental:
:reproducible:
:icons: font
:listing-caption: Listing
:sectnums:
:toc:
:toclevels: 3
:xrefstyle: short
:nofooter:

[%notitle]
--
[abstract]
{description}
--

== Açıklama
`@PreAuthorize` `@RolesAllowed` ve `@Secured` öğelerinin tümü, method güvenliğini yapılandırmaya izin veren annotationlardır. Hem bireysel metodlara hem de sınıf düzeyinde uygulanabilirler Method düzeyinde güvenlik, Spring AOP proxies'leri kullanılarak gerçekleştirilir.

== @PreAuthorize
Spring Security 3 ile birlikte `@PreAuthorize` and `@PostAuthorize` desteklemiştir.

`Spring Expression Language` (SpEL) kullanılarak bir metoda erişim kısıtlamalarının belirlenmesine olanak tanır. Bu kısıtlamalar, metod yürütülmeden önce değerlendirilir ve kısıtlamalar yerine getirilmezse, metodun yürütülmesinin reddedilmesine neden olabilir.

Spring Security framework'ün bir parçasıdır. Kullanabilmek için `@EnableGlobalMethodSecurity` annotationdaki `prePostEnabled` özniteliğinin true olarak ayarlanması gerekir
[source,kotlin]
----
//@EnableGlobalMethodSecurity(prePostEnabled = true)

@PreAuthorize("hasRole('ROLE_VIEWER') or hasRole('ROLE_EDITOR')") // OR, AND olabilir
fun isValidUsername(username:String?): Boolean = false
----
Daha detaylı örneği link:https://github.com/senocak/Kotlin-Spring-Blog-Boilerplate/blob/b4c4c6840e84d3226b022cfd0a3f421cc9a50cd8/spring-kotlin/src/main/kotlin/com/github/senocak/service/PostService.kt#L12[buradan] bulabilirsiniz

== @RolesAllowed

Kaynağı, link:https://jcp.org/en/jsr/detail?id=250[JSR-250] Java güvenlik standardındadır. Bu açıklama, yalnızca rol tabanlı güvenliği desteklediğinden @PreAuthorize ek açıklamasından daha sınırlıdır. Kullanmak için, bu açıklamayı içeren kitaplığın, Spring Security'nin bir parçası olmadığı için sınıf yolunda olması gerekir. Ek olarak, @EnableGlobalMethodSecurity ek açıklamasının jsr250Enabled özniteliğinin true olarak ayarlanması gerekir:
[source,kotlin]
----
//@EnableGlobalMethodSecurity(jsr250Enabled = true)

@RolesAllowed(value = ["ROLE_VIEWER", "ROLE_EDITOR"]) // OR ile seçilir
fun isValidUsername(username:String?): Boolean = false
----

== @Secured
Metod güvenliğini yapılandırmak için kullanılabilen eski bir Spring Security 2 annotationdır. Rol tabanlı güvenlikten fazlasını destekler, ancak güvenlik kısıtlamalarını belirtmek için Spring Expression Language (SpEL) kullanımını desteklemez. Yeni uygulamalarda @PreAuthorize notunun bu anotasyon üzerinden kullanılması tavsiye edilir. Kullanılması için @EnableGlobalMethodSecurity ek açıklamasında securedEnabled özniteliği etkinleştirilmesi gerekir:
[source,kotlin]
----
//@EnableGlobalMethodSecurity(securedEnabled=true)

@Secured("ROLE_ADMIN")
fun isValidUsername(username:String?): Boolean = false
----
TIP: @Secured ve @RolesAllowed aynı şeyi ifade eder ve farkı @Secured Spring'e özel bir annotationdır ancak @RolesAllowed Java standard annotationdır(#JSR250#).

== @PreFilter
Metodu çalıştırmadan önce bir koleksiyon bağımsız değişkenini filtrelemek için @PreFilter annotation'ı kullanılır
[source,kotlin]
----
import java.util.stream.Collectors

@PreFilter("filterObject != authentication.principal.username")
fun joinUsernames(usernames:List<String?>): String =
    usernames.stream().collect(Collectors.joining(";"))
----
Bu örnekte, kimliği doğrulanan kullanıcı dışındaki tüm kullanıcı adlarını birleştiriyoruz. Burada, ifademizde, koleksiyondaki mevcut nesneyi temsil etmek için filterObject adını kullanıyoruz. Ancak, metodun bir koleksiyon türü olan birden fazla argümanı varsa, hangi argümanı filtrelemek istediğimizi belirtmek için filterTarget özelliğini kullanmamız gerekir:

[source,kotlin]
----
import java.util.stream.Collectors

@PreFilter(value = "filterObject != authentication.principal.username", filterTarget = "usernames")
fun joinUsernamesAndRoles(usernames:List<String?>, roles:List<String?>): String =
    usernames.stream().collect(Collectors.joining(";")) + ":" + roles.stream().collect(Collectors.joining(";"))
----
== Sonuç
|===
|Security Annotation|SpEL Desteği

|@PreAuthorize|EVET
|@PostAuthorize|EVET
|@PreFilter|EVET
|@PostFilter|EVET
|@Secured|HAYIR
|@RolesAllowed|HAYIR
|===
